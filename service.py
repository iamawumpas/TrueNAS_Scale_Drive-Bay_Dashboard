import http.server, socketserver, json, time, subprocess, socket, os, re, threading

CONFIG_FILE = 'config.json'
LAST_CONFIG_TIME = 0
IS_CORRUPT = False

# HARD-CODED DEFAULTS (Now includes documentation remarks)
DEFAULT_CONFIG = {
    "__REMARK_NETWORK": "Port the web dashboard will be accessible on.",
    "network": {"port": 8010},
    
    "__REMARK_LAYOUT": "Visual sizing. VH = % of screen height. PX = Minimum fixed width.",
    "layout": {
        "chassis_count": 1, 
        "bays_per_chassis": 16, 
        "rows_per_chassis": 1, 
        "chassis_width_pct": 100, 
        "bay_height_vh": 48, 
        "bay_width_min_px": 40
    },
    
    "__REMARK_HARDWARE": "The PCI address of your HBA (find via lspci).",
    "hardware": {"hba_pci_address": "0000:00:10.0", "hba_name": "Main HBA Storage"},
    
    "__REMARK_COLORS": "Hex codes for the UI theme and LED status colors.",
    "colors": {
        "page_background": "#050505", "chassis_background": "#1a1a1a", "bay_background": "#121212",
        "text_serial": "#ffff00", "text_capacity": "#ff00ff", "text_pool": "#ffffff",
        "led_online": "#00ff00", "led_resilver": "#ffffff", "led_error": "#ffaa00",
        "led_offline": "#ff0000", "led_unused": "#8000ff", "led_activity": "#008cff"
    },
    
    "__REMARK_ZFS": "Formatting for pool names and unallocated drive labels.",
    "zfs_settings": {"show_index": True, "pool_separator": " - ", "unallocated_label": "&nbsp"}
}

CONFIG = DEFAULT_CONFIG.copy()

def startup_check():
    """Generates the config file with remarks if it is missing."""
    global LAST_CONFIG_TIME
    if not os.path.exists(CONFIG_FILE):
        print(f"[{time.strftime('%H:%M:%S')}] Startup: Generating config.json with documentation...")
        try:
            with open(CONFIG_FILE, 'w') as f:
                # indent=4 makes the autogenerated file human-readable
                json.dump(DEFAULT_CONFIG, f, indent=4)
            LAST_CONFIG_TIME = os.path.getmtime(CONFIG_FILE)
        except Exception as e:
            print(f"Startup Error: Could not create config file: {e}")

def reload_config_if_changed():
    global CONFIG, LAST_CONFIG_TIME, IS_CORRUPT
    try:
        if not os.path.exists(CONFIG_FILE):
            if not IS_CORRUPT:
                print(f"[{time.strftime('%H:%M:%S')}] Warning: config.json missing. Using memory defaults.")
            IS_CORRUPT = True
            CONFIG = DEFAULT_CONFIG.copy()
            return
        
        mtime = os.path.getmtime(CONFIG_FILE)
        if mtime > LAST_CONFIG_TIME:
            with open(CONFIG_FILE, 'r') as f:
                content = f.read()
                if not content.strip(): raise ValueError("File is empty")
                CONFIG = json.loads(content)
            LAST_CONFIG_TIME = mtime
            IS_CORRUPT = False
            print(f"[{time.strftime('%H:%M:%S')}] Config Reloaded.")
    except Exception as e:
        IS_CORRUPT = True
        CONFIG = DEFAULT_CONFIG.copy()
        print(f"!!! CONFIG ERROR: {e}")

# --- STARTUP SEQUENCE ---
startup_check()
reload_config_if_changed()

DISK_CACHE = {"topology": {}, "io_activity": {}, "last_update": 0, "hostname": socket.gethostname()}

def get_io_snapshot():
    activity = {}
    try:
        with open('/proc/diskstats', 'r') as f:
            for line in f:
                p = line.split()
                if len(p) >= 13: activity[p[2]] = int(p[3]) + int(p[7])
    except: pass
    return activity

def background_monitor():
    global DISK_CACHE
    last_io, cooldowns = {}, {}
    while True:
        cur = get_io_snapshot()
        for dev, count in cur.items():
            prev = last_io.get(dev, count)
            if count > prev: cooldowns[dev] = 2
            elif cooldowns.get(dev, 0) > 0: cooldowns[dev] -= 1
            last_io[dev] = count
        DISK_CACHE["io_activity"] = {d: (v > 0) for d, v in cooldowns.items()}
        time.sleep(0.1)

def update_heavy_stats():
    global DISK_CACHE
    reload_config_if_changed()
    l_cfg, h_cfg, z_cfg = CONFIG.get('layout',{}), CONFIG.get('hardware',{}), CONFIG.get('zfs_settings',{})
    pci, bays = h_cfg.get('hba_pci_address', '0000:00:10.0'), l_cfg.get('bays_per_chassis', 16)
    
    uuid_to_dev = {}
    if os.path.exists('/dev/disk/by-partuuid'):
        for uid in os.listdir('/dev/disk/by-partuuid'):
            try: uuid_to_dev[uid] = os.path.basename(os.path.realpath('/dev/disk/by-partuuid/'+uid)).rstrip('0123456789')
            except: pass

    z_p, z_s = {}, {}
    try:
        z_out = subprocess.check_output(['zpool', 'status'], text=True)
        cur_p, d_idx = None, 0
        for line in z_out.split('\n'):
            line = line.strip()
            if line.startswith('pool:'): cur_p, d_idx = line.split(':')[1].strip(), 0
            match = re.search(r'([0-9a-f-]{36}|vda[0-9]|sd[a-z]+[0-9]?)', line)
            if match and cur_p and "STATE" not in line and cur_p not in line:
                uid = match.group(1)
                d_idx += 1
                dev = uuid_to_dev.get(uid, uid).rstrip('0123456789')
                z_p[dev] = f"{cur_p}{z_cfg.get('pool_separator',' - ')}{d_idx}" if z_cfg.get("show_index") else cur_p
                z_s[dev] = line.split()[1]
    except: pass

    new_topo = {pci: [{"bay": f"BAY {i}", "status": "EMPTY", "sn": "---", "size": "---", "led": "off"} for i in range(1, bays + 1)]}
    if os.path.exists('/dev/disk/by-path'):
        for entry in os.scandir('/dev/disk/by-path'):
            if entry.is_symlink() and "-part" not in entry.name:
                parts = entry.name.split('-')
                if (parts[1] if len(parts)>1 else "") != pci: continue
                bay_num = -1
                for p in parts:
                    if any(x in p for x in ["phy", "ata", "sas"]):
                        f = re.findall(r'\d+', p)
                        if f: bay_num = int(f[0])
                if 0 <= bay_num < bays:
                    dev = os.path.basename(os.path.realpath(entry.path))
                    try:
                        lb = subprocess.check_output(['lsblk', '-dbno', 'SERIAL,SIZE', entry.path], text=True).strip().split()
                        sn, sz = lb[0][-3:], "{:.1f}TB".format(int(lb[1])/(1024**4))
                    except: sn, sz = "???", "???"
                    st = z_s.get(dev, "UNUSED")
                    led = "green" if st=="ONLINE" else "white" if st in ["RESILVER","REPLACING"] else "red" if st in ["OFFLINE","FAULTED"] else "purple" if st=="UNUSED" else "orange"
                    new_topo[pci][bay_num] = {"bay": f"BAY {bay_num+1}", "status": "PRESENT", "sn": sn, "size": sz, "pool": z_p.get(dev, z_cfg.get("unallocated_label"," ")), "led": led, "dev_name": dev}
    DISK_CACHE["topology"], DISK_CACHE["last_update"] = new_topo, time.time()

class DiskHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/data':
            if time.time() - DISK_CACHE["last_update"] > 5: update_heavy_stats()
            merged = {pci: [{**d, "active": DISK_CACHE["io_activity"].get(d.get("dev_name"), False)} for d in disks] for pci, disks in DISK_CACHE["topology"].items()}
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            self.wfile.write(json.dumps({"hostname": DISK_CACHE["hostname"], "topology": merged, "config": CONFIG, "version": LAST_CONFIG_TIME, "corrupt": IS_CORRUPT}).encode())
        else: return super().do_GET()

if __name__ == "__main__":
    threading.Thread(target=background_monitor, daemon=True).start()
    update_heavy_stats()
    socketserver.TCPServer.allow_reuse_address = True
    with socketserver.TCPServer(("0.0.0.0", CONFIG.get('network',{}).get('port', 8010)), DiskHandler) as httpd:
        httpd.serve_forever()